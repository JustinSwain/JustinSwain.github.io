<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="/style/style.css">
<link rel="icon" href="/images/spacecat.png">
<title>Justin Swain - Cat Casino</title>
<style>
  body {
    margin: 0;
    padding: 20px 0;
    min-height: 100vh;
    font-family: 'Dos', monospace;
    background: var(--space7) var(--body-bg-image) repeat;
    color: white;
  }
  /* CASINO CONTAINER */
  .casino {
    width: 90%;
    max-width: 1000px;
    margin: 0 auto;
    background: var(--space6);
    border: 3px solid var(--space1);
    border-radius: 12px;
    padding: 25px;
    text-align: center;
    box-shadow: 0 0 20px var(--space2), inset 0 0 30px rgba(1, 55, 217, 0.3);
  }

  h1 {
    font-family: 'Arcade', sans-serif;
    color: var(--space0);
    text-align: center;
    font-size: 3.5rem;
    margin: 0 0 20px 0;
    text-shadow: 0 0 15px var(--space2), 0 0 30px var(--space1);
    letter-spacing: 4px;
  }
  .store-link {
  font-family: 'Arcade', sans-serif;
  font-size: 1rem;
  background: var(--space4);
  color: gold;
  border: 3px solid gold;
  padding: 15px 35px;
  border-radius: 12px;
  text-decoration: none;
  display: inline-block;
  margin: 15px;
  box-shadow: 0 0 25px rgba(255,215,0,0.6);
  transition: all 0.3s;
}

.store-link:hover {
  background: gold;
  color: var(--space7);
  transform: scale(1.05);
  box-shadow: 0 0 40px gold;
}
  /* BALANCE DISPLAY */
  .balance {
    font-family: 'Dos', monospace;
    font-size: 2rem;
    color: var(--space0);
    background: var(--space7);
    border: 2px solid var(--space1);
    padding: 10px 30px;
    border-radius: 8px;
    display:inline-block;
    box-shadow: 0 0 15px var(--space3);
    margin-bottom: 20px;
  }

  .slot-container {
    position: relative;
    display: flex;
    justify-content: center;
    gap: 18px;
    background: var(--space7);
    padding: 30px 20px;
    border: 4px solid var(--space1);
    border-radius: 16px;
    box-shadow: 
      inset 0 0 40px var(--space2),
      0 0 30px rgba(74, 112, 226, 0.6);
  }

  .reel {
    width: 150px;
    height: 450px;
    overflow: hidden;
    border: 6px solid var(--space1);
    border-radius: 16px;
    background: linear-gradient(to bottom, #000816, #001248);
    box-shadow: 0 0 20px var(--space2), inset 0 0 20px #000;
  }
  /* SYMBOLS */
  .strip {
    display: flex;
    flex-direction: column;
  }

  .symbol {
    width: 150px;
    height: 150px;
    object-fit:contain;
    image-rendering: pixelated; /* retro crispness */
    border-bottom: 3px solid var(--space4);
  }
  /* BUTTONS */
  #buttons {
    align-items: center; margin: 475px 10px 10px;
  }

  button {
    font-family: 'Arcade', sans-serif;
    font-size: 1.8rem;
    background: var(--space5);
    color: var(--space0);
    border: 3px solid var(--space1);
    padding: 16px 50px;
    border-radius: 12px;
    cursor: pointer;
    box-shadow: 0 8px var(--space3);
    transition: all 0.2s;
    /* margin: 60px 10px 10px; */
  }

  button:hover {
    background: var(--space3);
    box-shadow: 0 0 20px var(--space1);
    transform: translateY(-4px);
  }

  button:active {
    transform: translateY(4px);
    box-shadow: 0 4px var(--space3);
  }

  button:disabled {
    background: #000816;
    color: #444;
    cursor: not-allowed;
    box-shadow: none;
  }
  .auto-spin-controls {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;
  margin: 20px 0;
  justify-content: center;
}

#autoSpins {
  background: var(--space7);
  color: var(--space0);
  border: 2px solid var(--space1);
  padding: 10px;
  border-radius: 8px;
  font-family: 'Dos', monospace;
  font-size: 1.1rem;
  min-width: 100px;
}

#toggleAuto {
  font-family: 'Arcade', sans-serif;
  font-size: 1.3rem;
  background: var(--space4);
  color: gold;
  border: 2px solid gold;
  padding: 12px 25px;
  border-radius: 10px;
  cursor: pointer;
  box-shadow: 0 0 20px rgba(255,215,0,0.5);
  transition: all 0.3s;
}

#toggleAuto:hover:not(:disabled) {
  background: gold;
  color: var(--space7);
  transform: scale(1.05);
  box-shadow: 0 0 30px gold;
}

#toggleAuto:disabled {
  background: #444;
  color: #777;
  cursor: not-allowed;
  box-shadow: none;
}

#toggleAuto.auto-running {
  background: #f00;
  color: white;
  border-color: #f66;
  animation: pulse 1s infinite;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.1); }
}
    /* MESSAGE DISPLAY */
  .message {
    font-family: 'Arcade', sans-serif;
    font-size: 2.2rem;
    text-align: center;
    min-height: 80px;
    margin: 20px 0;
    text-shadow: 0 0 15px var(--space2);
  }

  .jackpot {
    color: gold !important;
    animation: jackpotPulse 0.8s infinite alternate;
  }

  @keyframes jackpotPulse {
    from { text-shadow: 0 0 20px gold, 0 0 40px orange; }
    to   { text-shadow: 0 0 40px gold, 0 0 80px red; }
  }
.red-btn {
  background: #500;
  color: #f88;
  border-color: #f00;
  box-shadow: 0 0 25px #800;
}

.red-btn:hover {
  background: #f00;
  color: white;
  box-shadow: 0 0 40px #f00;
}

#begMessage {
  margin-top: 15px;
  font-weight: bold;
}
  /* ------- PAYLINES OVERLAY ------- */
  #payLines {
    position: relative; 
    margin: -450px auto 0 50%; 
    pointer-events: none; 
  }
  .lines-overlay {
    position: absolute;
    top: 30px;
    left: 20px;
    /* width: calc(100% - 40px); */
    height: 450px;
    pointer-events: none;
    z-index: 10;
  }

  .line {
    position: absolute;
    width: 800px;
    max-width: 170%;
    height: 450px;
    opacity: 0;
    transition: opacity 0.9s;
    background: linear-gradient(90deg, gold 40%, gold 50%, gold 60%);
    mix-blend-mode: screen;
    box-shadow: 0 0 30px gold;
  }
  .line.show { opacity: 0.7; }
  /* PAYLINE SHAPES */
    .line1 { 
        clip-path: polygon(0 10%, 100% 10%, 100% 15%, 0 15%); 
        transform: translateX(-50%); 
        background: red;
    }     
    .line2 { 
        clip-path: polygon(0 42%, 100% 42%, 100% 47%, 0 47%); 
        transform: translateX(-50%); 
        background: teal;
    }  
    .line3 { 
        clip-path: polygon(0 75%, 100% 75%, 100% 80%, 0 80%); 
        transform: translateX(-50%); 
        background: purple;
    } 
    .line4 { 
        clip-path: polygon(0 0%, 50% 85%, 100% 0%, 100% 5%, 50% 90%, 0 5%); 
        transform: translateX(-50%); 
        background: green;
    } 
    .line5 { 
        clip-path: polygon(0 90%, 50% 5%, 100% 90%, 100% 85%, 50% 0%, 0 85%); 
        transform: translateX(-50%); 
        background: gold;
    }
    .line6 { 
        clip-path: polygon(0 10%, 25% 10%, 75% 75%, 100% 75%, 100% 78%, 75% 78%, 25% 13%, 0% 13%); 
        transform: translateX(-50%); 
        background: orange;
    }
    .line7 { 
        clip-path: polygon(0 77%, 25% 77%, 75% 12%, 100% 12%, 100% 15%, 75% 15%, 25% 80%, 0% 80%); 
        transform: translateX(-50%); 
        background: cyan;
    }

/* PAYTABLE BUTTON */
#paytableBtn {
  font-family: 'Arcade', sans-serif;
  font-size: 1.4rem;
  background: var(--space6);
  color: var(--space0);
  border: 2px solid var(--space1);
  padding: 10px 25px;
  border-radius: 8px;
  cursor: pointer;
  margin: 15px 10px;
  box-shadow: 0 0 15px var(--space2);
  transition: all 0.3s;
}
#paytableBtn:hover {
  background: var(--space3);
  transform: scale(1.05);
  box-shadow: 0 0 25px gold;
}

/* MODAL */
.modal {
  display: none;
  position: fixed;
  z-index: 10000;
  left: 0; top: 0;
  width: 100%; height: 100%;
  background-color: rgba(0,7,27,0.92);
  backdrop-filter: blur(4px);
}
.modal-content {
  background: var(--space7);
  margin: 8% auto;
  padding: 30px;
  border: 4px solid var(--space1);
  width: 90%;
  max-width: 700px;
  max-height: 80%;
  overflow-y: auto;
  border-radius: 16px;
  box-shadow: 0 0 40px var(--space2);
  position: relative;
}
.close {
  color: var(--space0);
  float: right;
  font-size: 40px;
  font-weight: bold;
  cursor: pointer;
  position: absolute;
  top: 10px;
  right: 25px;
}
.close:hover { color: gold; }
/* JACKPOT DISPLAY */
.jackpot-display {
  font-family: 'Arcade', sans-serif;
  font-size: 2.2rem;
  color: gold;
  background: linear-gradient(90deg, var(--space7), var(--space4));
  border: 3px solid gold;
  padding: 12px 35px;
  border-radius: 12px;
  display: inline-block;
  margin: 15px 10px;
  box-shadow: 
    0 0 25px gold, 
    inset 0 0 20px rgba(255,215,0,0.3);
  animation: jackpotGlow 2s ease-in-out infinite alternate;
  text-shadow: 0 0 15px gold;
}

@keyframes jackpotGlow {
  from { box-shadow: 0 0 25px gold, inset 0 0 20px rgba(255,215,0,0.3); }
  to   { box-shadow: 0 0 45px #ffd700, inset 0 0 40px rgba(255,215,0,0.6); }
}

.jackpot-win {
  animation: jackpotExplode 1s ease-out;
}
@keyframes jackpotExplode {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.3); }
  100% { transform: scale(1); }
}
/* PRNG SELECTOR */
.prng-selector {
  margin: 15px;
  font-family: 'Dos', monospace;
  color: var(--space0);
  font-size: 1.1rem;
}
.prng-selector select {
  background: var(--space7);
  color: var(--space0);
  border: 2px solid var(--space1);
  padding: 8px;
  border-radius: 6px;
  font-family: 'Dos', monospace;
}
.prng-selector select option {
  background: var(--space6);
}
/* RNG STATS PANEL */
.rng-stats-panel {
  margin: 25px auto;
  padding: 20px;
  background: #000816;
  border: 3px solid var(--space1);
  border-radius: 14px;
  max-width: 700px;
  font-family: 'Dos', monospace;
  color: var(--space0);
  box-shadow: 0 0 30px var(--space2), inset 0 0 20px #001;
}

.stats-title {
  font-family: 'Arcade', sans-serif;
  font-size: 1.8rem;
  color: gold;
  text-align: center;
  margin-bottom: 15px;
  text-shadow: 0 0 15px gold;
  letter-spacing: 3px;
}

.stats-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  font-size: 1.1rem;
}

.stats-grid > div {
  background: rgba(255,255,255,0.05);
  padding: 10px;
  border-radius: 8px;
  border-left: 4px solid var(--space3);
}

.label {
  color: var(--space1);
  font-weight: bold;
}

#bias, #runs, #serial {
  /* color: #0f0; */
  font-weight: bold;
}

/* Color code statistical health */
.good   { color: #0f0; }
.warn   { color: #ff0; }
.bad    { color: #f66; }

/* TOOLTIPS  */
.stat-item {
  position: relative;
  cursor: help;
  padding: 10px;
  background: rgba(255,255,255,0.05);
  border-radius: 8px;
  border-left: 4px solid var(--space3);
  transition: all 0.3s;
}

.stat-item:hover {
  background: rgba(255,255,255,0.12);
  border-left-color: var(--space1);
  transform: translateY(-2px);
}

/* Tooltip bubble */
.stat-item::after {
  content: attr(data-tip);
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  background: translateY(10px);
  background: var(--space7);
  color: var(--space0);
  padding: 12px 16px;
  border: 2px solid var(--space1);
  border-radius: 10px;
  font-size: 0.95rem;
  font-family: 'Dos', monospace;
  white-space: wrap;
  opacity: 0;
  pointer-events: none;
  transition: all 0.4s ease;
  z-index: 100;
  box-shadow: 0 0 20px var(--space2);
  text-align: center;
  max-width: 300px;
  line-height: 1.4;
}

.stat-item:hover::after {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

/* Little arrow under tooltip */
.stat-item::before {
  content: '';
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 8px solid transparent;
  border-top-color: var(--space1);
  opacity: 0;
  transition: all 0.4s;
  overflow-wrap: normal;
}

.stat-item:hover::before {
  opacity: 1;
  transform: translateX(-50%) translateY(-8px);
}

.stat-item:hover::before {
  opacity: 1;
}

#resetStatsBtn {
  font-family: 'Arcade', sans-serif;
  font-size: 1.3rem;
  background: #300;
  border: 2px solid #f00;
  border-radius: 10px;
  cursor: pointer;
  box-shadow: 0 0 20px #800, inset 0 0 15px #500;
  transition: all 0.3s;
}

#resetStatsBtn:hover {
  background: #500;
  color: #fff;
  box-shadow: 0 0 35px #f00, inset 0 0 20px #900;
  transform: scale(1.05);
}

#resetStatsBtn:active {
  transform: scale(0.95);
}

/* PAYTABLE TABLE TABLE TABLE*/
.paytable {
  width: 100%;
  border-collapse: collapse;
  margin: 20px 0;
  font-size: 1.1rem;
}
.paytable th, .paytable td {
  padding: 12px;
  text-align: center;
  border: 1px solid var(--space3);
}
.paytable th {
  background: var(--space5);
  color: var(--space0);
  font-family: 'Arcade';
}
.paytable tr:nth-child(even) { background: rgba(255,255,255,0.03); }
.paytable img {
  width: 50px;
  height: 50px;
  image-rendering: pixelated;
  vertical-align: middle;
}
.paytable td:first-child {
  text-align: left;
  font-weight: bold;
}


#showLines {
    padding:10px 30px;
    margin-top: 20px; 
    font-size:0.8rem;
  }
/* ------------------------------- MOBILE ------------------------------- */
@media (max-width: 920px) {
  .casino {
    width: 98%;
    margin: 10px auto;
    padding: 15px 8px;
  }

  h1 {
    font-size: 2.6rem;
    letter-spacing: 2px;
    margin-bottom: 10px;
  }

  .balance {
    font-size: 1.6rem;
    padding: 8px 20px;
  }

  .slot-container {
    gap: 10px;
    padding: 20px 10px;
  }

  .reel {
    width: 100px;
    height: 300px;
    border-width: 4px;
  }

  .symbol {
    width: 100px;
    height: 100px;
  }
  #buttons {
    margin: 310px 10px 10px;
  }

  #payLines {
    position: relative; 
    margin: -300px auto 0 50%; 
    pointer-events: none; 
    max-width: 100%;
  }
  .line {
    width: 450px;
    height: 300px;
  }

  button {
    font-size: 1.5rem;
    padding: 14px 30px;
    margin: 12px 6px;
  }

  .message {
    font-size: 1.8rem;
    min-height: 60px;
  }
}

/* Mobile */
@media (max-width: 600px) {
  .paytable img { width: 40px; height: 40px; }
  .paytable { font-size: 0.95rem; }
  #paytableBtn { width: 90%; margin: 15px auto; display: block; }
}

@media (max-width: 480px) {
  h1 { font-size: 2.2rem; }

  .reel {
    width: 84px;
    height: 252px;
  }

  .symbol {
    width: 84px;
    height: 84px;
  }
  #buttons {
    margin: 280px 10px 10px;
  }
  #payLines {
    position: relative; 
    margin: -260px auto 0 50%; 
    pointer-events: none; 
    max-width: 100%;
  }
  .line {
    width: 400px;
    height: 252px;
  }
  .lines-overlay {
    top: 20px;
    left: 10px;
    width: calc(100% - 20px);
    height: 180px;
  }

  button {
    font-size: 1.3rem;
    padding: 12px 24px;
    width: 90%;
    margin: 10px auto;
    display: block;
  }

  .balance {
    font-size: 1.4rem;
  }
}

@media (max-height: 600px) and (orientation: landscape) {
  .casino { padding: 10px; }
  h1 { font-size: 2rem; }
}
</style>
</head>

<!-- Coin Rain -->
<canvas id="coinRainCanvas" 
        style="
          position: fixed;
          top: 0; left: 0; width: 100vw; height: 100vh;
          pointer-events: none; z-index: 9999;
          display: none;
          background: radial-gradient(circle at 50% 20%, rgba(255,215,0,0.1) 0%, transparent 70%);
        ">
</canvas>
<body>
<div class="casino">
  <h1>Cat Casino</h1>
  <div class="balance">Coins: <span id="coins">1000</span></div>
    <!-- Jackpot Display -->
    <div class="jackpot-display">
        CATNIP JACKPOT: <span id="jackpot">1000</span> coins
    </div>

    <div class="slot-container" id="slot"></div>

    <!-- PAYLINES  -->
    <div id="payLines">
        <div class="line line1" id="line1"></div>
        <div class="line line2" id="line2"></div>
        <div class="line line3" id="line3"></div>
        <div class="line line4" id="line4"></div>
        <div class="line line5" id="line5"></div>
        <div class="line line6" id="line6"></div>
        <div class="line line7" id="line7"></div>
    </div>

    <!-- Game Buttons -->
    <div id="buttons">
        <button id="spin">
            SPIN - 10 coins
        </button>
        <!-- ADD THIS INSIDE .controls div (next to your SPIN button) -->
<div class="auto-spin-controls">
  <label for="autoSpins">Auto-Spin:</label>
  <select id="autoSpins">
    <option value="0">Off</option>
    <option value="10">10 spins</option>
    <option value="25">25 spins</option>
    <option value="50">50 spins</option>
    <option value="100">100 spins</option>
    <option value="-1">Unlimited</option>
  </select>
  <button id="toggleAuto">START AUTO</button>
</div>

        <br>
        <button id="showLines">
            Show / Hide Paylines
        </button>
    </div>
  
    <div class="message" id="message">Good luck!</div>

    <a href="/p/fun/toys/store/" class="store-link">ðŸ›’ CAT CARD STORE</a>
    <br>
    <!-- PAYTABLE BUTTON -->
    <button id="paytableBtn" class="glow-btn">PAYTABLE</button>

    <!-- PAYTABLE TABLE TABLE TABLE -->
<div id="paytableModal" class="modal">
    <div class="modal-content">
        <span class="close">X</span>
        <h2 style="font-family:'Arcade';color:var(--space0);text-align:center;margin:0 0 20px;">
            PAYTABLE
        </h2>

    <table class="paytable">
      <thead>
        <tr>
          <th>SYMBOL</th>
          <th>5x</th>
          <th>4x</th>
          <th>3x</th>
        </tr>
      </thead>
      <tbody>
        <tr><td><img src="/images/toys/enemy3.png" alt="Larry"> LARRY</td>   <td>1000</td><td>200</td><td>50</td></tr>
        <tr><td><img src="/images/toys/zed.png" alt="zed"> ZED</td>           <td>800</td> <td>150</td><td>40</td></tr>
        <tr><td><img src="/images/toys/pluto.png" alt="pluto"> PLUTO</td>     <td>600</td> <td>120</td><td>35</td></tr>
        <tr><td><img src="/images/toys/enemy2.png" alt="Gary"> GARY</td> <td>500</td> <td>100</td><td>30</td></tr>
        <tr><td><img src="/images/toys/ninja.png" alt="ninja"> NINJA</td>     <td>400</td> <td>80</td> <td>25</td></tr>
        <tr><td><img src="/images/toys/jinx2.png" alt="jinx"> JINX</td>     <td>300</td> <td>60</td> <td>20</td></tr>
        <tr><td><img src="/images/toys/enemy1.png" alt="Harry"> HARRY</td>       <td>250</td> <td>50</td> <td>15</td></tr>
        <tr><td><img src="/images/toys/beans.png" alt="beans"> BEANS</td>   <td>200</td> <td>40</td> <td>12</td></tr>
        <tr><td><img src="/images/toys/ball.png" alt="ball"> BALL (Free Spins)</td>
            <td colspan="3" style="color:gold;text-align:center;">3=20 + 10 FS <br> 4=50 + 15 FS <br> 5=100 + 25 FS</td></tr>
        <tr><td><img src="/images/toys/goal.png" alt="Food"> FOOD! (Wild)</td>
            <td colspan="3" style="color:gold;text-align:center;">Substitutes for all symbols except BALL<br>5 Wilds = 1500 coins!</td></tr>
      </tbody>
    </table>

    <div style="margin-top:20px;text-align:center;color:var(--space1);font-size:0.9em;">
        All wins x2 during Free Spins <br> 7 Paylines <br> Bet = 10 coins
    </div>
  </div>
</div>

<!-- BANKRUPT MODAL -->
<div id="bankruptModal" class="modal" style="display:none;">
  <div class="modal-content">
    <span class="close" onclick="closeBankruptModal()">x</span>
    <h2 style="font-family:'Arcade'; color:#f66; text-shadow:0 0 15px #f00;">BANKRUPT!</h2>
    <p>The cats have claimed all your coins! What now?</p>
    <button id="resetCoins" class="glow-btn red-btn">RESET GAME (1000 free coins)</button>
    <button id="begCats" class="glow-btn">BEG THE CATS (200 daily coins)</button>
    <p id="begMessage" style="color:#f66; display:none;">The cats are unimpressed - come back tomorrow!</p>
  </div>
</div>

<!-- PRNG SELECTION MENU -->
<div class="prng-selector">
  <label for="prng">Pseudo Random Number Generator</label>
  <br>
  <select id="prng" style="font-size: 1rem;">
    <option value="math">Math.random() (Default)</option>
    <option value="lfsr">LFSR (32-bit)</option>
    <option value="xorshift32">XorShift32</option>
    <option value="chacha8">ChaCha8</option>
  </select>
</div>

<!-- RNG STATS PANEL -->
<div class="rng-stats-panel">
  <div class="stats-title">REAL-TIME PRNG ANALYSIS</div>
  <div class="stats-grid">
    <div class="stat-item" data-tip="Total number of random bits used by the slot machine.">
      <span class="label">Bits Generated:</span> <span id="bitsCount">0</span>
    </div>

    <div class="stat-item" data-tip="The number of 1-bits divided by total bits. Close to 0.5 is good.">
      <span class="label">Bias (p=1):</span> <span id="bias">0.50000</span>
    </div>

    <div class="stat-item" data-tip="Longest streak of 1-bits seen so far. Should be about log2(total bits).">
      <span class="label">Longest run of 1s:</span> <span id="runs">0</span>
    </div>

    <div class="stat-item" data-tip="Serial Correlation: the correlation between successive 32-bit outputs. Close to 0 is good.">
      <span class="label">Serial Corr.:</span> <span id="serial">0</span>
    </div>

    <div class="stat-item" data-tip="The symbol that appears most often.">
      <span class="label">Most Common:</span> <span id="hotSymbol">0</span>
    </div>

    <div class="stat-item" data-tip="The symbol that appears least often.">
      <span class="label">Least Common:</span> <span id="coldSymbol">0</span>
    </div>

    <div class="stat-item" data-tip="Current pseudorandom number generator being used by the slot machine. Switch in the dropdown above to test different algorithms.">
      <span class="label">Current RNG:</span> <span id="currentRng">0</span>
    </div>
    <div class="stat-tem">
        <button id="resetStatsBtn" style="padding:8px 20px; font-size:0.75rem; margin:0;">
            RESET STATISTICS
        </button>
  </div>
</div>
</div>

<!-- SCRIPTS -->
<script>
const catImages = [
  "/images/toys/goal.png", // WILD
  "/images/toys/ball.png", // FREE SPINS
  "/images/toys/enemy1.png",
  "/images/toys/ninja.png",
  "/images/toys/jinx2.png",
  "/images/toys/beans.png",
  "/images/toys/enemy2.png",
  "/images/toys/pluto.png",
  "/images/toys/zed.png",
  "/images/toys/enemy3.png"
];

// -------- SYMBOL PAYTABLE 5/4/3x --------
const PAYTABLE = {
  // filename.png : [5x, 4x, 3x] payout in coins
  "enemy3.png": [1000, 200, 50],   // SUPER RARE
  "zed.png":    [800,  150, 40],   // Very rare
  "pluto.png":  [600,  120, 35],
  "enemy2.png": [500,  100, 30],
  "ninja.png":  [400,   80, 25],
  "jinx2.png":  [300,   60, 20],
  "enemy1.png": [250,   50, 15],   // common
  "beans.png":  [200,   40, 12],
  "ball.png":   [150,   30, 10],   // scatter â€“ but also pays on lines
  "goal.png":   [0,     0,   0]    // WILD - never pays on its own
};

// -------- Random Weights --------
const SYMBOL_WEIGHTS = {
  "enemy3.png": 3,   // Ultra rare = low weight
  "zed.png":    4,
  "pluto.png":  5,
  "enemy2.png": 7,
  "ninja.png":  10,
  "jinx2.png":  13,
  "enemy1.png": 16,
  "beans.png":  20,
  "ball.png":   3,   // Scatter â€“ medium
  "goal.png":   5    // Wild
};

// -------- PRNG MENU --------
class RNG {
  static instance = null;

  constructor() {
    // pick last-used PRNG or default
    this.type = localStorage.getItem('selectedPRNG') || 'xorshift32';

    // ChaCha internal buffer
    this._chachaState = null;
    this._chachaBlock = null;
    this._chachaIndex = 16; // force initial refill

    // seed based on time; you can pass an explicit seed later
    const seed = (Date.now() ^ (performance.now() * 1000)) >>> 0;
    this.init(this.type, seed);

    if (typeof this.applySelector === 'function') {
      this.applySelector();
    }
  }

  /**
   * Initialize / reinitialize the PRNG.
   * @param {string} type - 'lfsr' | 'xorshift32' | 'chacha8' | 'math'
   * @param {number} [seed] - 32-bit seed
   */
  init(type, seed) {
    this.type = type;
    const s = (seed >>> 0) || ((Date.now() ^ (Math.random() * 0xffffffff)) >>> 0) || 1;

    switch (type) {
      case 'lfsr':
        // avoid all-zero lockup
        this.state = s || 1;
        break;

      case 'xorshift32':
        // xorshift32 cycles through all non-zero 32-bit states
        this.state = s || 1;
        break;

      case 'chacha8':
        this._initChaCha(s);
        break;

      default: // 'math' or unknown
        this.state = null;
        break;
    }

    // remember choice
    localStorage.setItem('selectedPRNG', this.type);
  }

  /**
   * Return a random float in (0,1).
   */
  random() {
    switch (this.type) {
      case 'lfsr':
        return this._randLFSR();
      case 'xorshift32':
        return this._randXorshift32();
      case 'chacha8':
        return this._randChaCha8();
      default:
        // pure Math.random fallback 
        const x = Math.random();
        // push it away from 0 and 1
        return (x * (1 - 2 ** -53)) + 2 ** -54;
    }
  }

  // --------------------
  // LFSR (32-bit Fibonacci)
  // taps: [32, 30, 26, 25] -> bit offsets [0, 2, 6, 7]
  // --------------------
  _randLFSR() {
    let x = this.state >>> 0;
    const bit = (x ^ (x >>> 2) ^ (x >>> 6) ^ (x >>> 7)) & 1;
    x = (x >>> 1) | (bit << 31);
    this.state = x >>> 0;
    // state never hits 0 if we seeded non-zero, so result is strictly in (0,1)
    return this.state / 0x100000000;
  }

  // --------------------
  // Xorshift32
  // Classic Marsaglia xorshift with period 2^32-1
  // --------------------
  _randXorshift32() {
    let x = this.state >>> 0;
    if (x === 0) x = 1; // just in case

    x ^= x << 13;
    x >>>= 0;
    x ^= x >>> 17;
    x >>>= 0;
    x ^= x << 5;
    x >>>= 0;

    this.state = x;

    // x is non-zero 32-bit; map to (0,1)
    return this._u32ToUnitOpen(x);
  }

  // Map a 32-bit unsigned int to (0,1)
  _u32ToUnitOpen(u) {
    // u is 1..2^32-1 ideally
    // add 1 and divide by 2^32+1 to avoid 0 and 1 exactly
    const num = (u + 1) >>> 0;
    return num / 4294967297; // 2^32 + 1
  }

  // --------------------
  // ChaCha8 PRNG
  // --------------------

  _initChaCha(seed) {
    // ChaCha constants
    const constWords = [
      0x61707865, // "expa"
      0x3320646e, // "nd 3"
      0x79622d32, // "2-by"
      0x6b206574  // "te k"
    ];

    this._chachaState = new Uint32Array(16);
    this._chachaBlock = new Uint32Array(16);
    this._chachaIndex = 16; // empty

    // simple key/nonce derivation from seed
    const k0 = seed >>> 0;
    let k1 = seed ^ 0x9e3779b9;
    k1 = (k1 ^ (k1 << 13)) >>> 0;
    k1 = (k1 ^ (k1 >>> 17)) >>> 0;
    k1 = (k1 ^ (k1 << 5)) >>> 0;

    // Fill 8 key words with simple expansions
    const key = new Uint32Array(8);
    for (let i = 0; i < 8; i++) {
      key[i] = (k0 + i * 0x9e3779b9) ^ (k1 >>> i);
    }

    const nonce0 = (seed ^ 0x12345678) >>> 0;
    const nonce1 = (seed ^ 0xdeadbeef) >>> 0;
    const nonce2 = (seed ^ 0x0badc0de) >>> 0;

    // state layout: 4 const, 8 key, 1 counter, 3 nonce
    const s = this._chachaState;
    s[0] = constWords[0];
    s[1] = constWords[1];
    s[2] = constWords[2];
    s[3] = constWords[3];

    for (let i = 0; i < 8; i++) {
      s[4 + i] = key[i];
    }

    s[12] = 0;          // counter
    s[13] = nonce0;
    s[14] = nonce1;
    s[15] = nonce2;
  }

  _rotl32(x, n) {
    x >>>= 0;
    return ((x << n) | (x >>> (32 - n))) >>> 0;
  }

  _chachaQuarterRound(x, a, b, c, d) {
    x[a] = (x[a] + x[b]) >>> 0;
    x[d] ^= x[a]; x[d] = this._rotl32(x[d], 16);

    x[c] = (x[c] + x[d]) >>> 0;
    x[b] ^= x[c]; x[b] = this._rotl32(x[b], 12);

    x[a] = (x[a] + x[b]) >>> 0;
    x[d] ^= x[a]; x[d] = this._rotl32(x[d], 8);

    x[c] = (x[c] + x[d]) >>> 0;
    x[b] ^= x[c]; x[b] = this._rotl32(x[b], 7);
  }

  _chachaBlock8Rounds() {
    const s = this._chachaState;
    const x = this._chachaBlock;

    // copy state
    for (let i = 0; i < 16; i++) x[i] = s[i];

    // 8 rounds = 4 column rounds + 4 diagonal rounds
    for (let i = 0; i < 4; i++) {
      // column rounds
      this._chachaQuarterRound(x, 0, 4, 8, 12);
      this._chachaQuarterRound(x, 1, 5, 9, 13);
      this._chachaQuarterRound(x, 2, 6, 10, 14);
      this._chachaQuarterRound(x, 3, 7, 11, 15);

      // diagonal rounds
      this._chachaQuarterRound(x, 0, 5, 10, 15);
      this._chachaQuarterRound(x, 1, 6, 11, 12);
      this._chachaQuarterRound(x, 2, 7, 8, 13);
      this._chachaQuarterRound(x, 3, 4, 9, 14);
    }

    // add original state
    for (let i = 0; i < 16; i++) {
      x[i] = (x[i] + s[i]) >>> 0;
    }

    // increment counter
    s[12] = (s[12] + 1) >>> 0;
  }

  _randChaCha8() {
    if (this._chachaIndex >= 16) {
      this._chachaBlock8Rounds();
      this._chachaIndex = 0;
    }
    const word = this._chachaBlock[this._chachaIndex++];
    return this._u32ToUnitOpen(word);
  }

  applySelector() {
    const select = document.getElementById('prng');
    select.value = this.type;
    select.onchange = (e) => {
      this.type = e.target.value;
      localStorage.setItem('selectedPRNG', this.type);
      this.init(this.type);
      console.log(`Switched to ${this.type.toUpperCase()} RNG`);
    };
  }
}

// Global RNG instance 
const rng = new RNG();

const RNGStats = {
  calls: 0,
  bitCount: 0,
  oneCount: 0,
  currentRun: 0,
  longestRunOnes: 0,
  symbolCounts: {},

  // serial correlation accumulators
  prevWord: null,
  pairCount: 0,
  sumX: 0,
  sumY: 0,
  sumXX: 0,
  sumYY: 0,
  sumXY: 0,

  init() {
    const el = document.getElementById('currentRng');
    if (el) {
      el.textContent = rng.type.toUpperCase();
    }
    setInterval(() => this.updateDisplay(), 1500);
  },

  recordCall() {
    this.calls++;
    this.bitCount += 32; // each rng.random() treated as 32-bit word
  },

  recordSymbol(filename) {
    this.symbolCounts[filename] = (this.symbolCounts[filename] || 0) + 1;
  },

  // Assumes rng.random() did u32 / 2^32 (or (u32+0.5)/2^32)
  recordFloat(value) {
    let u = Math.floor(value * 0x100000000);

    if (u >= 0x100000000) {
      u = 0xFFFFFFFF; // clamp if extremely close to 1.0
    }
    u >>>= 0;

    // ---- bit statistics (bias + longest 1-run) ----
    for (let i = 0; i < 32; i++) {
      const bit = (u >>> (31 - i)) & 1;
      if (bit === 1) {
        this.oneCount++;
        this.currentRun++;
        if (this.currentRun > this.longestRunOnes) {
          this.longestRunOnes = this.currentRun;
        }
      } else {
        this.currentRun = 0;
      }
    }

    // ---- serial correlation stats on word level ----
    // normalize to [0,1] to keep sums numerically nice
    const x = u / 0xFFFFFFFF;

    if (this.prevWord !== null) {
      const px = this.prevWord / 0xFFFFFFFF;
      const py = x;

      this.pairCount++;
      this.sumX  += px;
      this.sumY  += py;
      this.sumXX += px * px;
      this.sumYY += py * py;
      this.sumXY += px * py;
    }

    this.prevWord = u;
  },

  updateDisplay() {
    // Current RNG type
    const rngEl = document.getElementById('currentRng');
    if (rngEl) {
      rngEl.textContent = rng.type.toUpperCase();
    }

    // Total bits (approx, in kbits)
    const bitsEl = document.getElementById('bitsCount');
    if (bitsEl) {
      bitsEl.textContent = Math.floor(this.bitCount / 1000) + 'k';
    }

    // Bias toward 1s
    const bias = this.bitCount > 0 ? this.oneCount / this.bitCount : 0.5;
    const biasEl = document.getElementById('bias'); 
    if (biasEl) {
      biasEl.textContent = bias.toFixed(5);
      biasEl.className =
        Math.abs(bias - 0.5) < 0.005 ? 'good' :
        Math.abs(bias - 0.5) < 0.02  ? 'warn' :
                                       'bad';
    }

    // Longest run of 1s
    const runsEl = document.getElementById('runs');
    if (runsEl) {
      runsEl.textContent = this.longestRunOnes;
      runsEl.className =
        this.longestRunOnes <= 12 ? 'good' :
        this.longestRunOnes <= 20 ? 'warn' :
                                    'bad';
    }

    // ---- Serial correlation between successive 32-bit outputs ----
    let rho = 0;
    if (this.pairCount > 1) {
      const n = this.pairCount;
      const num   = n * this.sumXY - this.sumX * this.sumY;
      const denomX = n * this.sumXX - this.sumX * this.sumX;
      const denomY = n * this.sumYY - this.sumY * this.sumY;
      const denom = Math.sqrt(denomX * denomY);

      if (denom > 0) {
        rho = num / denom;
      } else {
        rho = 0;
      }
    }

    const serialEl = document.getElementById('serial'); 
    if (serialEl) {
      serialEl.textContent = rho.toFixed(4);
      const a = Math.abs(rho);
      serialEl.className =
        a < 0.01 ? 'good' :
        a < 0.05 ? 'warn' :
                   'bad';
    }

    // Hot / cold symbols
    const entries = Object.entries(this.symbolCounts);
    if (entries.length > 0) {
      const sorted = entries.sort((a, b) => b[1] - a[1]);
      const hotEl  = document.getElementById('hotSymbol');
      const coldEl = document.getElementById('coldSymbol');
        let characters = {
            "enemy3.png": "Larry",
            "zed.png": "Zed",
            "pluto.png": "Pluto",
            "enemy2.png": "Gary",
            "ninja.png": "Ninja",
            "jinx2.png": "Jinx",
            "enemy1.png": "Harry",
            "beans.png": "Beans",
            "ball.png": "Ball",
            "goal.png": "Food"
        }
      if (hotEl) {
        hotEl.textContent = `${characters[sorted[0][0]]} (${sorted[0][1]})`;
      }
      if (coldEl) {
        const last = sorted[sorted.length - 1];
        coldEl.textContent = `${characters[last[0]]} (${last[1]})`;
      }
    }
  }
};


// -------- SAFE HOOK --------
(function hookSafely() {
  if (window._rngStatsHooked) return;
  window._rngStatsHooked = true;

  const realRandom = rng.random.bind(rng);

  rng.random = function(...args) {
    const value = realRandom(...args);
    RNGStats.recordCall();
    RNGStats.recordFloat(value);
    return value;
  };

  if (typeof window.pickRandomSymbol === 'function') {
    const realPick = window.pickRandomSymbol;
    window.pickRandomSymbol = function(...args) {
      const sym = realPick.apply(this, args);
      RNGStats.recordSymbol(getFilename(sym));
      return sym;
    };
  }

  RNGStats.init();
})();

// -------- RESET STATS BUTTON --------
document.getElementById('resetStatsBtn').addEventListener('click', () => {
  // Reset all counters
  RNGStats.calls = 0;
  RNGStats.bitCount = 0;
  RNGStats.oneCount = 0;
  RNGStats.currentRun = 0;
  RNGStats.longestRunOnes = 0;
  RNGStats.symbolCounts = {};
  RNGStats.prevWord = null,
  RNGStats.pairCount = 0,
  RNGStats.sumX = 0,
  RNGStats.sumY = 0,
  RNGStats.sumXX = 0,
  RNGStats.sumYY = 0,
  RNGStats.sumXY = 0,

  // Force immediate display update
  RNGStats.updateDisplay();

  // flashy feedback
  const btn = document.getElementById('resetStatsBtn');
  btn.textContent = 'CLEARED!';
  btn.style.background = '#060';
  btn.style.color = '#0f0';
 0;
  setTimeout(() => {
    btn.textContent = 'RESET STATISTICS';
    btn.style.background = '#300';
    btn.style.color = '#f66';
  }, 800);
});


// Weighted random symbol picker
function pickRandomSymbol() {
  const filenames = Object.keys(SYMBOL_WEIGHTS);
  const totalWeight = filenames.reduce((sum, name) => sum + SYMBOL_WEIGHTS[name], 0);
  let rand = rng.random() * totalWeight;

  for (const filename of filenames) {
    rand -= SYMBOL_WEIGHTS[filename];
    if (rand <= 0) {
      // Find matching image path
      return catImages.find(path => getFilename(path) === filename) || catImages[0];
    }
  }
  return catImages[0]; // Failsafe
}

// Default for any symbol not listed above (safety net)
const DEFAULT_PAYOUT = [100, 25, 8];

const WILD_FILENAME     = "goal.png";     //  wild
const SCATTER_FILENAME  = "jinx2.png";     //  scatter

// -------- ROBUST FILENAME HELPER --------
function getFilename(src) {
  // Safety first â€“ if anything weird happens, return empty string
  if (!src || typeof src !== "string") return "";
  // Extract just the filename (works with full URLs, relative paths, query strings, etc.)
  const parts = src.split(/[\\/]/);           // split on / or \
  let filename = parts[parts.length - 1];     // last part
  filename = filename.split('?')[0];        // remove query string or hash
  return filename;
}
function isWild(src)     { return getFilename(src) === "goal.png"; }
function isScatter(src)  { return getFilename(src) === "ball.png"; }

// -------- FREE SPINS TRACKING --------
let freeSpinsToPlay = 0;

// Track how many were originally awarded (for display)
function startFreeSpins(count) {
  freeSpinsToPlay = count;
  localStorage.setItem('lastFreeSpinsAwarded', count);
}

// -------- SLOT MACHINE SETUP --------
const REEL_LENGTH = 60;           // length of one reel strip
// === DYNAMIC SYMBOL HEIGHT â€“ ALWAYS CORRECT ===
// This reads the actual rendered size of any symbol on the page
function getSymbolHeight() {
  const anySymbol = document.querySelector(".symbol");
  if (anySymbol) {
    return anySymbol.getBoundingClientRect().height;
  }
  // Fallback values in case DOM isn't ready yet
  if (window.innerWidth <= 480) return 84;
  if (window.innerWidth <= 920) return 100;
  return 150;
}

// Symbol position
let SYMBOL_HEIGHT = getSymbolHeight();

// Update it on every resize (mobile rotate, desktop resize, etc.)
window.addEventListener("resize", () => {
  SYMBOL_HEIGHT = getSymbolHeight();
});

const slot = document.getElementById("slot");
const strips = [];                // current reel strips
let coins = parseInt(localStorage.getItem('coins')) || 1000;
const bet = 10;

// Function to save coins
function saveCoins() {
  localStorage.setItem('coins', coins.toString());
  document.getElementById('coins').textContent = coins;
}

document.getElementById("coins").textContent = coins;

// -------- PROGRESSIVE JACKPOT --------
let jackpot = parseInt(localStorage.getItem('catSlotJackpot')) || 1000;
const jackpotSeed = 1000;
const jackpotIncrement = 1; // +1 coin per spin

function updateJackpotDisplay() {
  document.getElementById('jackpot').textContent = jackpot.toLocaleString();
  localStorage.setItem('catSlotJackpot', jackpot.toString());
}

// Load on page start
updateJackpotDisplay();

// Build 5 empty reels
for (let i = 0; i < 5; i++) {
  const reel = document.createElement("div");
  reel.className = "reel";
  const strip = document.createElement("div");
  strip.className = "strip";
  reel.appendChild(strip);
  slot.appendChild(reel);
  strips.push(strip);
}

// Generate a completely random reel strip of 60 symbols
// with rarity-weighting
function generateRandomStrip() {
  const strip = document.createElement("div");
  strip.className = "strip";
  for (let i = 0; i < REEL_LENGTH; i++) {
    const img = document.createElement("img");
    img.className = "symbol";
    img.src = pickRandomSymbol();  // WEIGHTED!
    strip.appendChild(img);
  }
  return strip;
}

// Start with fresh random strips
strips.forEach((old, i) => {
  const newStrip = generateRandomStrip();
  old.parentNode.replaceChild(newStrip, old);
  strips[i] = newStrip;
});

// === COIN RAIN ON BIG WINS ===
const canvas = document.getElementById('coinRainCanvas');
const ctx = canvas.getContext('2d');

let animationId = null;
let coinss = [];

// Resize canvas to full screen
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Coin particle class
class Coin {
  constructor(x, winAmount) {
    this.x = x;
    this.y = -50 - rng.random() * 50;
    this.vy = 2 + rng.random() * 4;
    this.vx = (rng.random() - 0.5) * 2;
    this.size = 12 + rng.random() * 8 + (Math.min(winAmount,1000) / 100);
    this.rotation = rng.random() * Math.PI * 2;
    this.rotSpeed = (rng.random() - 0.5) * 0.1;
    this.life = 10;
    this.decay = 0.98 + rng.random() * 0.01;
    this.sparkle = rng.random() * Math.PI * 2;
  }

  update() {
    this.y += this.vy;
    this.x += this.vx;
    this.rotation += this.rotSpeed;
    this.sparkle += 0.3;
    this.life *= this.decay;

    // Bounce near bottom
    if (this.y > canvas.height - 100) {
      this.vy *= -0.7;
      this.y = canvas.height - 100;
      this.vx *= 0.95;
    }

    // Side bounce
    if (this.x < 20 || this.x > canvas.width - 20) {
      this.vx *= -0.8;
      this.x = Math.max(20, Math.min(canvas.width - 20, this.x));
    }
  }

  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    ctx.globalAlpha = this.life;

    // Shiny gold coin
    const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, this.size);
    grad.addColorStop(0, `rgba(255, 215, 0, ${this.life})`);
    grad.addColorStop(0.6, `rgba(218, 165, 32, ${this.life * 0.8})`);
    grad.addColorStop(1, `rgba(139, 69, 19, ${this.life * 0.4})`);

    ctx.fillStyle = grad;
    ctx.shadowColor = 'gold';
    ctx.shadowBlur = 20 * this.life;
    ctx.beginPath();
    ctx.arc(0, 0, this.size, 0, Math.PI * 2);
    ctx.fill();

    // Edge highlight
    ctx.strokeStyle = `rgba(255, 255, 255, ${this.life * 0.6})`;
    ctx.lineWidth = 2;
    ctx.stroke();

    // Sparkle
    ctx.fillStyle = `hsla(${this.sparkle * 57}, 100%, 70%, ${this.life})`;
    ctx.beginPath();
    ctx.arc(this.size * 0.3, -this.size * 0.3, 3, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }
}

// Start the coin rain animation
function startCoinRain(winAmount) {
  coinss = [];
  canvas.style.display = 'block';

  // More coins = bigger win!
  const numCoins = Math.ceil(Math.min(winAmount,500) / 10);

  for (let i = 0; i < numCoins; i++) {
    coinss.push(new Coin(
      rng.random() * canvas.width,
      winAmount
    ));
  }

  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    coinss.forEach(coin => {
      coin.update();
      coin.draw();
    });

    // Remove dead coins
    coinss = coinss.filter(coin => coin.life > 0.01);

    if (coinss.length > 0) {
      animationId = requestAnimationFrame(animate);
    } else {
      canvas.style.display = 'none';
    }
  }

  animate();

  // Force stop after 5 seconds max
  setTimeout(() => {
    if (animationId) {
      cancelAnimationFrame(animationId);
      canvas.style.display = 'none';
    }
  }, 5000);
}

function getMiddleRowSymbols() {
  return strips.map(strip => {
    const symbols = strip.querySelectorAll(".symbol");
    const offset = Math.abs(parseFloat(strip.dataset.offset || 0));
    const idx = Math.floor(offset / SYMBOL_HEIGHT) % REEL_LENGTH;
    return symbols[idx].src;
  });
}

// ------------------------------
// 5 CLASSIC PAYLINES
// ------------------------------
const paylines = [
  [0, 0, 0, 0, 0], // Line 1 â€“ top row
  [1, 1, 1, 1, 1], // Line 2 â€“ middle row
  [2, 2, 2, 2, 2], // Line 3 â€“ bottom row
  [0, 1, 2, 1, 0], // Line 4 â€“ V shape
  [2, 1, 0, 1, 2], // Line 5 â€“ ^ shape
  [0, 0, 1, 2, 2], // Line 6 â€“ zigzag down
  [2, 2, 1, 0, 0], // Line 7 â€“ zigzag up
];

// Returns a 3Ã—5 grid [row][column] of image URLs
function getGrid() {
  const grid = [[], [], []]; // 3 rows

  strips.forEach((strip, col) => {
    const symbols = strip.querySelectorAll(".symbol");
    const offset = Math.abs(parseFloat(strip.dataset.offset || 0));
    const startIdx = Math.floor(offset / SYMBOL_HEIGHT) % REEL_LENGTH;

    grid[0].push(symbols[(startIdx + 0) % REEL_LENGTH].src); // top row
    grid[1].push(symbols[(startIdx + 1) % REEL_LENGTH].src); // middle
    grid[2].push(symbols[(startIdx + 2) % REEL_LENGTH].src); // bottom
  });

  return grid;
}

// Checks if a sequence of symbols matches (considering wilds)
function isMatchingSequence(lineSymbols, start, length) {
  let baseSymbol = null;
  for (let i = 0; i < length; i++) {
    const sym = lineSymbols[start + i];
    if (sym !== WILD_SRC) {
      if (baseSymbol === null) {
        baseSymbol = sym;
      } else if (sym !== baseSymbol) {
        return false;
      }
    }
  }
  return true;
}

// Calculate win for a single payline
function getLineWin(lineSymbols) {
  let matchLength = 0;
  let targetSymbol = null;   

  for (let i = 0; i < 5; i++) {
    const current = lineSymbols[i];

    if (isWild(current)) {
      matchLength++;
      continue;
    }

    if (targetSymbol === null) {
      targetSymbol = current;
      matchLength++;
      continue;
    }

    if (current === targetSymbol) {
      matchLength++;
      continue;
    }

    break; 
  }

  if (matchLength < 3) return 0;

  // Get payout for the actual symbol (not wild)
  const filename = getFilename(targetSymbol || "");
  const payoutArray = PAYTABLE[filename] || DEFAULT_PAYOUT;

  // Special case: 3+ WILDS on a line = big bonus (even if no targetSymbol)
  if (matchLength >= 3 && targetSymbol === null) {
    return matchLength === 5 ? 1500 : matchLength === 4 ? 400 : 100;
  }

  // Return correct payout based on match length
  return payoutArray[5 - matchLength]; // index 0 = 5x, 1 = 4x, 2 = 3x
}

// Calculate total win from all paylines and scatters
function calculateWin() {
  const grid = getGrid(); // 3x5 grid [row][col]
  let lineWin = 0;
  const winningLines = [];

  // Line wins (unchanged)
  paylines.forEach((pattern, lineIdx) => {
    const lineSymbols = [];
    for (let col = 0; col < 5; col++) {
      lineSymbols[col] = grid[pattern[col]][col];
    }
    const thisWin = getLineWin(lineSymbols);
    if (thisWin > 0) {
      lineWin += thisWin;
      winningLines.push(lineIdx + 1);
    }
  });

  // Scatter wins (unchanged)
  let scatterCount = 0;
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 5; col++) {
      if (isScatter(grid[row][col])) scatterCount++;
    }
  }
  let scatterWin = 0;
  let freeSpinsAwarded = 0;
  switch (scatterCount) {
    case 3: scatterWin = 20; freeSpinsAwarded = 3; break;
    case 4: scatterWin = 50; freeSpinsAwarded = 6; break;
    case 5: scatterWin = 100; freeSpinsAwarded = 10; break;
  }
  if (scatterCount > 5) {
    scatterWin = 100; // extra for >5
    freeSpinsAwarded = 10;
  } 
    if (scatterCount >= 3) {
    freeSpinsAwarded = scatterCount === 3 ? 3 : scatterCount === 4 ? 6 : 10;
    startFreeSpins(freeSpinsToPlay + freeSpinsAwarded); // proper chaining
    }

  // JACKPOT CHECK
  let jackpotWin = 0;
  // Triggers on 5 "enemy1.png" EXACTLY on MIDDLE LINE (line 2)
  const middlePattern = paylines[1]; // [1,1,1,1,1]
  const middleSymbols = middlePattern.map((row, col) => grid[row][col]);
  const allEnemy1 = middleSymbols.every(sym => getFilename(sym) === 'enemy1.png');
  if (allEnemy1) {
    jackpotWin = jackpot; // FULL JACKPOT!
  }

  return { 
    lineWin, 
    scatterWin, 
    freeSpinsAwarded, 
    jackpotWin,  
    winningLines 
  };
}

// REPLACE your ENTIRE spin button event listener with this:
document.getElementById("spin").addEventListener("click", () => {
  if (freeSpinsToPlay > 0 || document.getElementById("spin").disabled) {
    return; // Ignore clicks during free spins or spinning
  }
  if (coins < bet) {
    document.getElementById("message").textContent = "No coins? The cats are disappointed.";
    return;
  }
  coins -= bet;
  document.getElementById("coins").textContent = coins;
  saveCoins();
  spinReels(false);
});

// â”€â”€â”€â”€â”€â”€â”€â”€ AUTO-SPIN + SPACEBAR â”€â”€â”€â”€â”€â”€â”€â”€
let autoSpinsLeft = 0;
let autoRunning = false;
const spinBtn = document.getElementById('spin');
const autoSelect = document.getElementById('autoSpins');
const toggleAutoBtn = document.getElementById('toggleAuto');

// Load saved auto-spin preference
autoSelect.value = localStorage.getItem('autoSpinsPref') || '0';
autoSelect.addEventListener('change', () => {
  localStorage.setItem('autoSpinsPref', autoSelect.value);
});

// Toggle auto-spin
toggleAutoBtn.addEventListener('click', () => {
  if (autoRunning) {
    stopAutoSpin();
  } else {
    startAutoSpin();
  }
});

function startAutoSpin() {
  const num = parseInt(autoSelect.value);
  if (num === 0) return;

  autoSpinsLeft = num === -1 ? Infinity : num;
  autoRunning = true;
  toggleAutoBtn.textContent = 'STOP AUTO';
  toggleAutoBtn.classList.add('auto-running');
  spinBtn.disabled = true; // Prevent manual spins during auto

  // Start first spin
  performSpin();
}

function stopAutoSpin() {
  autoSpinsLeft = 0;
  autoRunning = false;
  toggleAutoBtn.textContent = 'START AUTO';
  toggleAutoBtn.classList.remove('auto-running');
  spinBtn.disabled = false; // Re-enable manual
}

function performSpin() {
  if (!autoRunning || autoSpinsLeft === 0 || freeSpinsToPlay > 0 || coins < bet) {
    stopAutoSpin();
    return;
  }

  // Trigger spin
  spinReels(false); // Normal spin (not free)

  // Decrement and schedule next
  if (autoSpinsLeft !== Infinity) autoSpinsLeft--;
  const nextDelay = 5000; // Wait for current spin to finish
  setTimeout(() => {
    if (autoRunning) performSpin();
  }, nextDelay);
}

// SPACEBAR SPIN
document.addEventListener('keydown', (e) => {
  if (e.code === 'Space' && !spinBtn.disabled && !autoRunning && freeSpinsToPlay === 0 && coins >= bet) {
    e.preventDefault();
    document.getElementById('spin').click();
  }
});

// Update spin button text for auto-countdown
const observer = new MutationObserver(() => {
  if (autoRunning && autoSpinsLeft !== Infinity && autoSpinsLeft > 0) {
    spinBtn.textContent = `AUTO: ${autoSpinsLeft}`;
  }
});
observer.observe(spinBtn, { childList: true, subtree: true });

// â”€â”€â”€â”€â”€â”€â”€â”€ BANKRUPT HANDLING (FIXED VERSION) â”€â”€â”€â”€â”€â”€â”€â”€
function showBankruptModal() {
  document.getElementById('bankruptModal').style.display = 'block';
}

function closeBankruptModal() {
  document.getElementById('bankruptModal').style.display = 'none';
}

// Attach listeners safely (after DOM ready)
window.addEventListener('load', () => {
  const resetBtn = document.getElementById('resetCoins');
  const begBtn = document.getElementById('begCats');
  const begMsg = document.getElementById('begMessage');

  if (resetBtn) {
    resetBtn.addEventListener('click', () => {
      console.log('Reset clicked â€“ resetting coins');
      coins = 1000;
      saveCoins();
      closeBankruptModal();
      document.getElementById('message').textContent = "Game reset! The cats give you mercy.";
    });
  } else {
    console.error('resetCoins button not found â€“ check HTML ID');
  }

  if (begBtn) {
    begBtn.addEventListener('click', () => {
      console.log('Beg clicked â€“ checking daily limit');
      const lastBeg = localStorage.getItem('lastBegTime');
      const now = Date.now();
      if (lastBeg && now - lastBeg < 86400000) {  // 24 hours
        begMsg.style.display = 'block';
        setTimeout(() => begMsg.style.display = 'none', 3000);
        return;
      }

      coins += 200;
      saveCoins();
      localStorage.setItem('lastBegTime', now);
      closeBankruptModal();
      document.getElementById('message').textContent = "The cats purr... 200 coins granted!";
    });
  } else {
    console.error('begCats button not found â€“ check HTML ID');
  }
});

// Check on every spin attempt
function spinReels(isFreeSpin) {
  if (!isFreeSpin && coins < bet) {
    showBankruptModal();
    return;
  }
  const spinButton = document.getElementById("spin");
  const messageEl = document.getElementById("message");

  jackpot += jackpotIncrement;
  updateJackpotDisplay();

  spinButton.disabled = true;

  // FREE SPINS COUNTER
  if (isFreeSpin) {
    const remaining = freeSpinsToPlay; // this is the number of spins LEFT (including current one)
    const totalAwarded = localStorage.getItem('lastFreeSpinsAwarded') || 10; // fallback
    messageEl.textContent = `${remaining} FREE SPINS!`;
  } else {
    messageEl.textContent = "SPINNING...";
  }

  // 1. RNG stop positions 
  const stopPositions = strips.map(() => (REEL_LENGTH / 2) - 3 + Math.floor(rng.random() * REEL_LENGTH / 2));

  // 2. Animate spin
  strips.forEach((strip, i) => {
    const fullSpins = 0 + Math.floor(rng.random() * 0);
    const finalOffset = (fullSpins * REEL_LENGTH + stopPositions[i]) * SYMBOL_HEIGHT;
    strip.style.transition = "none";
    strip.style.transform = "translateY(0px)";
    void strip.offsetHeight;
    strip.style.transition = `transform ${3.2 + i * 0.35}s cubic-bezier(0.18, 0.38, 0.32, 1)`;
    strip.style.transform = `translateY(-${finalOffset}px)`;
    strip.dataset.offset = finalOffset.toString();
  });

  // 3. After animation: replace strips
  setTimeout(() => {
    strips.forEach((oldStrip, i) => {
      const stopIdx = stopPositions[i];
      const oldSymbols = oldStrip.querySelectorAll(".symbol");
      const visible = [
        oldSymbols[stopIdx % REEL_LENGTH].src,
        oldSymbols[(stopIdx + 1) % REEL_LENGTH].src,
        oldSymbols[(stopIdx + 2) % REEL_LENGTH].src
      ];
      const newStrip = document.createElement("div");
      newStrip.className = "strip";
      for (let j = 0; j < 3; j++) {
        const img = document.createElement("img");
        img.className = "symbol";
        img.src = visible[j];
        newStrip.appendChild(img);
      }
     for (let j = 3; j < REEL_LENGTH; j++) {
        const img = document.createElement("img");
        img.className = "symbol";
        img.src = pickRandomSymbol();  // WEIGHTED
        newStrip.appendChild(img);
      }
      oldStrip.parentNode.replaceChild(newStrip, oldStrip);
      strips[i] = newStrip;
      newStrip.dataset.offset = "0";
    });

    // 4. EVALUATE WINS  
    const multiplier = isFreeSpin ? 2 : 1;
    const { lineWin, scatterWin, freeSpinsAwarded, jackpotWin, winningLines } = calculateWin();
    const totalWin = (lineWin + scatterWin) * multiplier + jackpotWin;  // ADDS JACKPOT!

    // Hide lines
    document.querySelectorAll(".line").forEach((el) => el.classList.remove("show"));

    let msg = "";
    if (totalWin > 0) {
      coins += totalWin;
      document.getElementById("coins").textContent = coins;
      saveCoins();

      if (jackpotWin > 0) {
        jackpot = jackpotSeed;
        updateJackpotDisplay();
        document.querySelector('.jackpot-display').classList.add('jackpot-win');
        setTimeout(() => document.querySelector('.jackpot-display').classList.remove('jackpot-win'), 2000);
      }

      msg = `YOU WON ${totalWin} COINS`;
      if (winningLines.length > 0) {
        msg += ` on line${winningLines.length > 1 ? "s" : ""} ${winningLines.join(", ")}`;
      }
    //   if (scatterWin > 0) msg += ` + ${freeSpinsAwarded} FREE SPINS`;
      messageEl.innerHTML = msg;
      messageEl.classList.add("jackpot");
      startCoinRain(totalWin);

      winningLines.forEach(n => {
        const lineEl = document.getElementById(`line${n}`);
        if (lineEl) {
          lineEl.classList.add("show");
          setTimeout(() => lineEl.classList.remove("show"), 4000);
        }
      });
    } else {
      // Still show free spin counter even on no-win
      if (isFreeSpin) {
        const remaining = freeSpinsToPlay;
        const total = localStorage.getItem('lastFreeSpinsAwarded') || 10;
        messageEl.textContent = `FREE SPINS! ${remaining}/${total}`;
      } else {
        let messages = [
          "No win this time, try again!",
          "The cats are fickle today.",
          "So close, yet so far!",
          "Jinx is going to buy chicken with your money.",
          "Pluto is laughing at you.",
          "Your coins will fund Ninja's extravagant lifestyle.",
          "Better luck next spin!",
          "The cats kept your coins..."
        ];
        messageEl.textContent = messages[Math.floor(rng.random() * messages.length)];
        // messageEl.textContent = "The cats kept your coinsâ€¦";
      }
      messageEl.classList.remove("jackpot");
    }

    // FREE SPINS TRIGGER
    if (freeSpinsAwarded > 0) {
    //   freeSpinsToPlay += freeSpinsAwarded;
      localStorage.setItem('lastFreeSpinsAwarded', freeSpinsToPlay); // remember total

      const bonusMsg = messageEl.innerHTML || messageEl.textContent;
      messageEl.innerHTML = bonusMsg + 
        `<br><span style="color:gold;font-size:1.6em;font-weight:bold;">
          +${freeSpinsAwarded} FREE SPINS!
        </span>`;
    }

    // AUTO-CHAIN FREE SPINS
    if (freeSpinsToPlay > 0) {
      freeSpinsToPlay--;
      setTimeout(() => spinReels(true), 3500);
    } else {
      spinButton.disabled = false;
      localStorage.removeItem('lastFreeSpinsAwarded'); // cleanup
    }
  }, 4500);
}

// Show/Hide paylines button
document.getElementById("showLines").addEventListener("click", () => {
  document.querySelectorAll('.line').forEach((el, i) => {
    el.classList.toggle('show');
  });
});

// PAYTABLE MODAL
const modal = document.getElementById("paytableModal");
const btn = document.getElementById("paytableBtn");
const span = document.getElementsByClassName("close")[0];

btn.onclick = () => modal.style.display = "block";
span.onclick = () => modal.style.display = "none";
window.onclick = (e) => { if (e.target === modal) modal.style.display = "none"; };
</script>
</body>
</html>